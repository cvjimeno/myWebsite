---
// src/components/blog/NewsletterCTA.astro
import Icon from "../common/Icon.astro";
---
<section class="starlight-field border-y border-border-card py-16 md:py-20">
  
  <div class="starlight-canvas" id="starlightCanvas"></div>
  
  <div class="relative z-10 max-w-2xl mx-auto px-4 sm:px-6 lg:px-8 text-center">
    <div class="bg-bg-primary p-8 md:p-10 rounded-xl shadow-lg border border-border-card">
      <div class="inline-flex items-center justify-center w-14 h-14 bg-blue-100 rounded-full mb-6">
        <Icon name="mail" size="w-7 h-7" class="text-accent-blue"/>
      </div>
      <h2 class="text-3xl md:text-4xl font-bold text-text-primary mb-4">Ãšnete a mis Apuntes Semanales</h2>
      <p class="text-lg text-text-secondary mb-8 leading-relaxed">Cada viernes comparto una idea sobre IA, un paper que me ha parecido interesante y una herramienta que estoy probando. Sin spam, solo contenido de alto valor.</p>
      <form class="max-w-md mx-auto">
        <div class="flex flex-col sm:flex-row gap-3">
          <input type="email" name="email" placeholder="tu@email.com" required class="flex-grow w-full bg-bg-secondary border-2 border-border-card rounded-lg px-4 py-3 focus:ring-2 focus:ring-accent-blue/50 focus:border-accent-blue transition"/>
          <button type="submit" class="px-6 py-3 bg-accent-blue text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 ring-offset-bg-primary focus:ring-accent-blue transition-all duration-300 hover:scale-105">Suscribirme</button>
        </div>
      </form>
    </div>
  </div>
</section>

<script>
  // A small helper function for debouncing
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  class StarlightField {
    constructor(container) {
      this.container = container;
      if (!this.container) return;

      this.neurons = [];
      this.connections = [];
      this.mouseX = 0;
      this.mouseY = 0;
      this.activationRadius = 150;

      // This is our main loop that runs constantly
      this.animate();
      this.setupEventListeners();
      
      // We wrap the expensive init() call in a debounced function
      this.debouncedInit = debounce(() => this.init(), 250);
      window.addEventListener('resize', this.debouncedInit);

      // Initial setup
      this.init();
    }

    init() {
      this.container.innerHTML = ''; // Clear old elements
      this.neurons = [];
      this.connections = [];
      
      const rect = this.container.getBoundingClientRect();
      if (rect.width === 0) return;

      // THE RESPONSIVE FIX: Calculate density based on viewport area
      // You can make the denominator smaller for more dots (e.g., 15000)
      const numNeurons = Math.floor((rect.width * rect.height) / 6000);

      for (let i = 0; i < numNeurons; i++) {
        this.createNeuron(rect);
      }
      this.createConnections();
    }
    
    // ... createNeuron and createConnection methods remain the same as the last version ...
     createNeuron(rect) {
      const neuronEl = document.createElement('div');
      neuronEl.className = 'neuron';
      const x = Math.random() * (rect.width - 20) + 10;
      const y = Math.random() * (rect.height - 20) + 10;
      neuronEl.style.left = `${x}px`;
      neuronEl.style.top = `${y}px`;
      this.neurons.push({ element: neuronEl, x, y });
      this.container.appendChild(neuronEl);
    }
    
        createConnections() {
      for (let i = 0; i < this.neurons.length; i++) {
        for (let j = i + 1; j < this.neurons.length; j++) {
          const neuron1 = this.neurons[i];
          const neuron2 = this.neurons[j];
          const distance = Math.sqrt(Math.pow(neuron1.x - neuron2.x, 2) + Math.pow(neuron1.y - neuron2.y, 2));

          // Connect if they are close enough, but with a bit of randomness
          if (distance < 180 && Math.random() < 0.5) {
            this.createConnection(neuron1, neuron2);
          }
        }
      }
    }

    createConnection(n1, n2) {
      const connEl = document.createElement('div');
      connEl.className = 'connection';
      const dX = n2.x - n1.x;
      const dY = n2.y - n1.y;
      const dist = Math.sqrt(dX * dX + dY * dY);
      const angle = Math.atan2(dY, dX) * 180 / Math.PI;
      connEl.style.width = `${dist}px`;
      connEl.style.left = `${n1.x + 2}px`;
      connEl.style.top = `${n1.y + 2}px`;
      connEl.style.transform = `rotate(${angle}deg)`;
      this.connections.push({ element: connEl, n1, n2 });
      this.container.appendChild(connEl);
    }
    // ... updateActivations method remains the same ...
    updateActivations() {
      this.neurons.forEach(neuron => {
        const dist = Math.sqrt(Math.pow(this.mouseX - neuron.x, 2) + Math.pow(this.mouseY - neuron.y, 2));
        if (dist < this.activationRadius) {
          neuron.element.classList.add('active');
        } else {
          neuron.element.classList.remove('active');
        }
      });
      this.connections.forEach(conn => {
        if (conn.n1.element.classList.contains('active') && conn.n2.element.classList.contains('active')) {
          conn.element.classList.add('active');
        } else {
          conn.element.classList.remove('active');
        }
      });
    }


    setupEventListeners() {
      const parent = this.container.parentElement;
      parent.addEventListener('mousemove', e => {
        const rect = parent.getBoundingClientRect();
        this.mouseX = e.clientX - rect.left;
        this.mouseY = e.clientY - rect.top;
      }, { passive: true });
    }

    animate() {
      if(this.container.parentElement.style.display !== 'none'){
        this.updateActivations();
        requestAnimationFrame(() => this.animate());
      }
    }
    
    // Cleanup method to remove listeners when the component is destroyed
    destroy() {
      window.removeEventListener('resize', this.debouncedInit);
    }
  }

  let fieldInstance = null;
  function initializeField() {
    // Clean up old instance if it exists
    if (fieldInstance) {
      fieldInstance.destroy();
    }
    const canvas = document.getElementById('starlightCanvas');
    if (canvas) {
      fieldInstance = new StarlightField(canvas);
    }
  }

  document.addEventListener('astro:page-load', initializeField);
  initializeField();

  // Add cleanup listener for when you navigate away
  document.addEventListener('astro:before-swap', () => {
    if (fieldInstance) {
      fieldInstance.destroy();
    }
  });
</script>




