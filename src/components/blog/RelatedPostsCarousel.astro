---
// src/components/blog/RelatedPostsCarousel.astro
import { getCollection } from 'astro:content';
import HorizontalPostCard from './HorizontalPostCard.astro';
import Button from '../common/Button.astro';

const { currentPostSlug, currentPostTags = [] } = Astro.props;
const allPosts = await getCollection('blog', (entry) => entry.slug !== currentPostSlug && !entry.data.draft);

const relatedPosts = allPosts.map(post => {
  const sharedTags = (post.data.tags || []).filter(tag => currentPostTags.includes(tag));
  return { post, sharedTagsCount: sharedTags.length };
})
.filter(item => item.sharedTagsCount > 0)
.sort((a, b) => b.sharedTagsCount - a.sharedTagsCount)
.slice(0, 6);

const shouldRender = relatedPosts.length >= 3;
---
{shouldRender && (
  <div class="mt-20 bg-[var(--color-bg-secondary)] border-y border-border-card py-16">
    <div class="max-w-5xl mx-auto px-4 sm:px-6 lg:px-8">
      <div class="flex justify-between items-center mb-8">
        {/* THE FIX: Smaller base font size for the heading */}
        <h2 class="text-2xl sm:text-3xl font-bold text-text-primary">Para seguir explorando</h2>
        
        {/* THE FIX: `flex-shrink-0` prevents the button from being squished and wrapping */}
        <a href="/blog" class="flex-shrink-0 inline-block px-5 py-2.5 bg-transparent border-2 border-accent-primary text-accent-primary text-sm font-medium rounded-lg hover:bg-accent-primary/[.10] transition-colors">
          Ver todo
        </a>
        </a>
      </div>
    </div>
    
    <div class="relative">
      <div id="carousel-container" class="flex overflow-x-auto gap-6 pb-4 px-4 sm:px-6 lg:px-8 scrollbar-hide">
        {relatedPosts.map((item) => (
          <div class="w-96 md:w-[420px] flex-shrink-0">
            <HorizontalPostCard post={item.post} />
          </div>
        ))}
      </div>

      {/* THE FIX: The mask now uses CSS variables to adapt automatically */}
      <div class="absolute inset-0 pointer-events-none" 
        style={`background: linear-gradient(to right, 
          var(--color-bg-secondary),  
          transparent 10%, 
          transparent 90%, 
          var(--color-bg-secondary)
        );`}>
      </div>
    </div>
  </div>
)}

<style>
  .scrollbar-hide::-webkit-scrollbar { display: none; }
  .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
</style>

<script>
function initializeInfiniteCarousel() {
  const container = document.getElementById('carousel-container');
  if (!container || container.dataset.initialized === 'true') return;
  container.dataset.initialized = 'true';

  // Clone items for the infinite loop
  const items = Array.from(container.children);
  if (items.length <= 1) return;
  items.forEach(item => {
    const clone = item.cloneNode(true);
    clone.setAttribute('aria-hidden', 'true');
    container.appendChild(clone);
  });

  let isScrolling;
  container.addEventListener('scroll', () => {
    clearTimeout(isScrolling);
    isScrolling = requestAnimationFrame(() => {
      // Get computed padding so we know the effective scroll area
      const computedStyle = getComputedStyle(container);
      const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
      const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
      
      // Effective scrollable width without the padding
      const effectiveScrollWidth = container.scrollWidth - paddingLeft - paddingRight;
      const halfwayPoint = effectiveScrollWidth / 2;
      
      const scrollLeft = container.scrollLeft - paddingLeft; // Adjusted scrollLeft

      if (scrollLeft >= halfwayPoint) {
        // Jump back and add the left padding back
        container.scrollLeft = scrollLeft - halfwayPoint + paddingLeft;
      } else if (scrollLeft <= 0) {
        // Jump forward and add the left padding back
        container.scrollLeft = scrollLeft + halfwayPoint + paddingLeft;
      }
    });
  }, { passive: true });
}

document.addEventListener('astro:page-load', initializeInfiniteCarousel);
initializeInfiniteCarousel();
</script>